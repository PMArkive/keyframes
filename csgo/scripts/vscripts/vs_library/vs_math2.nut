//-----------------------------------------------------------------------
//------------------- Copyright (c) samisalreadytaken -------------------
//-----------------------------------------------------------------------
if("AngleQuaternion"in::VS)return;;const FLT_EPSILON=1.19209290E-07;;const FLT_MAX=1.E+37;;const FLT_MIN=1.E-37;;class::Quaternion{x=0.0;y=0.0;z=0.0;w=0.0;constructor(_x=0.0,_y=0.0,_z=0.0,_w=0.0){x=_x;y=_y;z=_z;w=_w}function _add(d){return::Quaternion(x+d.x,y+d.y,z+d.z,w+d.w)}function _sub(d){return::Quaternion(x-d.x,y-d.y,z-d.z,w-d.w)}function _mul(d){return::Quaternion(x*d,y*d,z*d,w*d)}function _div(d){return::Quaternion(x/d,y/d,z/d,w/d)}function _unm(){return::Quaternion(-x,-y,-z,-w)}function _typeof(){return"Quaternion"}function _tostring(){return"Quaternion("+x+","+y+","+z+","+w+")"}}class::matrix3x4{constructor(xAxis=::Vector(),yAxis=::Vector(),zAxis=::Vector(),vecOrigin=::Vector()){Init();m_flMatVal[0][0]=xAxis.x;m_flMatVal[0][1]=yAxis.x;m_flMatVal[0][2]=zAxis.x;m_flMatVal[0][3]=vecOrigin.x;m_flMatVal[1][0]=xAxis.y;m_flMatVal[1][1]=yAxis.y;m_flMatVal[1][2]=zAxis.y;m_flMatVal[1][3]=vecOrigin.y;m_flMatVal[2][0]=xAxis.z;m_flMatVal[2][1]=yAxis.z;m_flMatVal[2][2]=zAxis.z;m_flMatVal[2][3]=vecOrigin.z}function Init(){m_flMatVal=::array(3);m_flMatVal[0]=::array(4,0);m_flMatVal[1]=::array(4,0);m_flMatVal[2]=::array(4,0)}function _typeof(){return"matrix3x4_t"}function _tostring(){return"matrix3x4_t"}m_flMatVal=null}if(VS.arrayFind(VS.slots_default,"Quaternion")==null){VS.slots_default.append("Quaternion");VS.slots_default.append("matrix3x4")};;local _VEC=::Vector();local _QUAT=::Quaternion();function VS::InvRSquared(v){return 1.0/::max(1.0,v.LengthSqr())}function VS::a_swap(a1,i1,a2,i2){local t=a1[i1];a1[i1]=a2[i2];a2[i2]=t}function VS::MatrixRowDotProduct(in1,row,in2){in1=in1.m_flMatVal;return in1[row][0]*in2.x+in1[row][1]*in2.y+in1[row][2]*in2.z}function VS::MatrixColumnDotProduct(in1,col,in2){in1=in1.m_flMatVal;return in1[0][col]*in2.x+in1[1][col]*in2.y+in1[2][col]*in2.z}function VS::DotProductAbs(in1,in2){return::fabs(in1.x*in2.x)+::fabs(in1.y*in2.y)+::fabs(in1.z*in2.z)}function VS::VectorTransform(in1,in2,out=_VEC){in2=in2.m_flMatVal;out.x=in1.x*in2[0][0]+in1.y*in2[0][1]+in1.z*in2[0][2]+in2[0][3];out.y=in1.x*in2[1][0]+in1.y*in2[1][1]+in1.z*in2[1][2]+in2[1][3];out.z=in1.x*in2[2][0]+in1.y*in2[2][1]+in1.z*in2[2][2]+in2[2][3];return out}function VS::VectorITransform(in1,in2,out=_VEC){in2=in2.m_flMatVal;local in1t=[in1.x-in2[0][3],in1.y-in2[1][3],in1.z-in2[2][3]];out.x=in1t[0]*in2[0][0]+in1t[1]*in2[1][0]+in1t[2]*in2[2][0];out.y=in1t[0]*in2[0][1]+in1t[1]*in2[1][1]+in1t[2]*in2[2][1];out.z=in1t[0]*in2[0][2]+in1t[1]*in2[1][2]+in1t[2]*in2[2][2];return out}function VS::VectorRotate(in1,in2,out=_VEC){in2=in2.m_flMatVal;out.x=in1.x*in2[0][0]+in1.y*in2[0][1]+in1.z*in2[0][2];out.y=in1.x*in2[1][0]+in1.y*in2[1][1]+in1.z*in2[1][2];out.z=in1.x*in2[2][0]+in1.y*in2[2][1]+in1.z*in2[2][2];return out}function VS::VectorRotate2(in1,in2,out=_VEC){local matRotate=::matrix3x4();AngleMatrix(in2,matRotate);VectorRotate(in1,matRotate,out);return out}function VS::VectorRotate3(in1,in2,out=_VEC){local matRotate=::matrix3x4();QuaternionMatrix(in2,matRotate);VectorRotate(in1,matRotate,out);return out}function VS::VectorIRotate(in1,in2,out=_VEC){in2=in2.m_flMatVal;out.x=in1.x*in2[0][0]+in1.y*in2[1][0]+in1.z*in2[2][0];out.y=in1.x*in2[0][1]+in1.y*in2[1][1]+in1.z*in2[2][1];out.z=in1.x*in2[0][2]+in1.y*in2[1][2]+in1.z*in2[2][2];return out}function VS::VectorMA(start,scale,direction,dest=_VEC){dest.x=start.x+scale*direction.x;dest.y=start.y+scale*direction.y;dest.z=start.z+scale*direction.z;return dest}function VS::VectorNegate(vec){vec.x=-vec.x;vec.y=-vec.y;vec.z=-vec.z;return vec}function VS::QuaternionsAreEqual(a,b,tolerance=0.0){local fabs=::fabs;return(fabs(a.x-b.x)<=tolerance&&fabs(a.y-b.y)<=tolerance&&fabs(a.z-b.z)<=tolerance&&fabs(a.w-b.w)<=tolerance)}function VS::QuaternionMA(p,s,q,qt=_QUAT){local q1=q*s;local p1=QuaternionMult(p,q1,::Quaternion());;QuaternionNormalize(p1);qt.x=p1.x;qt.y=p1.y;qt.z=p1.z;qt.w=p1.w;return qt}function VS::QuaternionAdd(p,q,qt=_QUAT){local q2=QuaternionAlign(p,q,::Quaternion());qt.x=p.x+q2.x;qt.y=p.y+q2.y;qt.z=p.z+q2.z;qt.w=p.w+q2.w;return qt}function VS::QuaternionDotProduct(p,q){return p.x*q.x+p.y*q.y+p.z*q.z+p.w*q.w}function VS::QuaternionMult(p,q,qt=_QUAT){if(p==qt){local p2=Quaternion(p.x,p.y,p.z,p.w);QuaternionMult(p2,q,qt);return qt};local q2=QuaternionAlign(p,q,::Quaternion());qt.x=p.x*q2.w+p.y*q2.z-p.z*q2.y+p.w*q2.x;qt.y=-p.x*q2.z+p.y*q2.w+p.z*q2.x+p.w*q2.y;qt.z=p.x*q2.y-p.y*q2.x+p.z*q2.w+p.w*q2.z;qt.w=-p.x*q2.x-p.y*q2.y-p.z*q2.z+p.w*q2.w;return qt}function VS::QuaternionAlign(p,q,qt=_QUAT){local a=(p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y)+(p.z-q.z)*(p.z-q.z)+(p.w-q.w)*(p.w-q.w),b=(p.x+q.x)*(p.x+q.x)+(p.y+q.y)*(p.y+q.y)+(p.z+q.z)*(p.z+q.z)+(p.w+q.w)*(p.w+q.w);if(a>b){qt.x=-q.x;qt.y=-q.y;qt.z=-q.z;qt.w=-q.w}else if(qt!=q){qt.x=q.x;qt.y=q.y;qt.z=q.z;qt.w=q.w};;return qt}function VS::QuaternionBlend(p,q,t,qt=_QUAT){local q2=QuaternionAlign(p,q,::Quaternion());QuaternionBlendNoAlign(p,q2,t,qt);return qt}function VS::QuaternionBlendNoAlign(p,q,t,qt=_QUAT){local sclp=1.0-t,sclq=t;qt.x=sclp*p.x+sclq*q.x;qt.y=sclp*p.y+sclq*q.y;qt.z=sclp*p.z+sclq*q.z;qt.w=sclp*p.w+sclq*q.w;QuaternionNormalize(qt);return qt}function VS::QuaternionIdentityBlend(p,t,qt=_QUAT){local sclp=1.0-t;qt.x=p.x*sclp;qt.y=p.y*sclp;qt.z=p.z*sclp;if(qt.w<0.0){qt.w=p.w*sclp-t}else{qt.w=p.w*sclp+t};QuaternionNormalize(qt);return qt}function VS::QuaternionSlerp(p,q,t,qt=_QUAT){local q2=QuaternionAlign(p,q,::Quaternion());QuaternionSlerpNoAlign(p,q2,t,qt);return qt}function VS::QuaternionSlerpNoAlign(p,q,t,qt=_QUAT){local omega,cosom,sinom,sclp,sclq;cosom=p.x*q.x+p.y*q.y+p.z*q.z+p.w*q.w;if((1.0+cosom)>0.000001){if((1.0-cosom)>0.000001){omega=::acos(cosom);sinom=::sin(omega);sclp=::sin((1.0-t)*omega)/sinom;sclq=::sin(t*omega)/sinom}else{sclp=1.0-t;sclq=t};qt.x=sclp*p.x+sclq*q.x;qt.y=sclp*p.y+sclq*q.y;qt.z=sclp*p.z+sclq*q.z;qt.w=sclp*p.w+sclq*q.w}else{sclp=::sin((1.0-t)*1.5708);sclq=::sin(t*1.5708);qt.x=sclp*p.x+sclq*qt.x;qt.y=sclp*p.y+sclq*qt.y;qt.z=sclp*p.z+sclq*qt.z;qt.w=q.z};return qt}function VS::QuaternionAngleDiff(p,q){local qInv=::Quaternion(),diff=::Quaternion();QuaternionConjugate(q,qInv);QuaternionMult(p,qInv,diff);local sinang=::min(1.0,::sqrt(diff.x*diff.x+diff.y*diff.y+diff.z*diff.z));local angle=::asin(sinang)*114.591559026;return angle}function VS::QuaternionConjugate(p,q){q.x=-p.x;q.y=-p.y;q.z=-p.z;q.w=p.w}function VS::QuaternionInvert(p,q){QuaternionConjugate(p,q);local magnitudeSqr=p.x*p.x+p.y*p.y+p.z*p.z+p.w*p.w;if(magnitudeSqr){local inv=1.0/magnitudeSqr;q.x*=inv;q.y*=inv;q.z*=inv;q.w*=inv;return};Assert(magnitudeSqr)}function VS::QuaternionNormalize(q){local iradius,radius=q.x*q.x+q.y*q.y+q.z*q.z+q.w*q.w;if(radius){radius=::sqrt(radius);iradius=1.0/radius;q.w*=iradius;q.z*=iradius;q.y*=iradius;q.x*=iradius};return radius}function VS::QuaternionMatrix(q,matrix,pos=null){matrix=matrix.m_flMatVal;matrix[0][0]=1.0-2.0*q.y*q.y-2.0*q.z*q.z;matrix[1][0]=2.0*q.x*q.y+2.0*q.w*q.z;matrix[2][0]=2.0*q.x*q.z-2.0*q.w*q.y;matrix[0][1]=2.0*q.x*q.y-2.0*q.w*q.z;matrix[1][1]=1.0-2.0*q.x*q.x-2.0*q.z*q.z;matrix[2][1]=2.0*q.y*q.z+2.0*q.w*q.x;matrix[0][2]=2.0*q.x*q.z+2.0*q.w*q.y;matrix[1][2]=2.0*q.y*q.z-2.0*q.w*q.x;matrix[2][2]=1.0-2.0*q.x*q.x-2.0*q.y*q.y;matrix[0][3]=0.0;matrix[1][3]=0.0;matrix[2][3]=0.0;if(pos){matrix[0][3]=pos.x;matrix[1][3]=pos.y;matrix[2][3]=pos.z}}function VS::QuaternionAngles(q,angles=_VEC){local m11=(2.0*q.w*q.w)+(2.0*q.x*q.x)-1.0,m12=(2.0*q.x*q.y)+(2.0*q.w*q.z),m13=(2.0*q.x*q.z)-(2.0*q.w*q.y),m23=(2.0*q.y*q.z)+(2.0*q.w*q.x),m33=(2.0*q.w*q.w)+(2.0*q.z*q.z)-1.0;angles.y=57.29577951*::atan2(m12,m11);angles.x=57.29577951*::asin(-m13);angles.z=57.29577951*::atan2(m23,m33);return angles}function VS::QuaternionAngles2(q,angles=_VEC){local matrix=::matrix3x4();QuaternionMatrix(q,matrix);MatrixAngles(matrix,angles);return angles}function VS::QuaternionAxisAngle(q,axis){local angle=::acos(q.w)*114.591559026;if(angle>180)angle-=360;axis.x=q.x;axis.y=q.y;axis.z=q.z;axis.Norm();return angle}function VS::AxisAngleQuaternion(axis,angle,q=_QUAT){angle=angle*0.008726645;local sa=::sin(angle),ca=::cos(angle);q.x=axis.x*sa;q.y=axis.y*sa;q.z=axis.z*sa;q.w=ca;return q}function VS::AngleQuaternion(angles,outQuat=_QUAT){local ay=angles.y*0.008726645,ax=angles.x*0.008726645,az=angles.z*0.008726645;local sy=::sin(ay),cy=::cos(ay),sp=::sin(ax),cp=::cos(ax),sr=::sin(az),cr=::cos(az);local srXcp=sr*cp,crXsp=cr*sp;outQuat.x=srXcp*cy-crXsp*sy;outQuat.y=crXsp*cy+srXcp*sy;local crXcp=cr*cp,srXsp=sr*sp;outQuat.z=crXcp*sy-srXsp*cy;outQuat.w=crXcp*cy+srXsp*sy;return outQuat}function VS::MatrixQuaternion(mat,q=_QUAT){local angles=MatrixAngles(mat);AngleQuaternion(angles,q);return q}function VS::BasisToQuaternion(vecForward,vecRight,vecUp,q=_QUAT){Assert(::fabs(vecForward.LengthSqr()-1.0)<1.e-3);Assert(::fabs(vecRight.LengthSqr()-1.0)<1.e-3);Assert(::fabs(vecUp.LengthSqr()-1.0)<1.e-3);local vecLeft=vecRight*-1.0;local mat=matrix3x4(vecForward,vecLeft,vecUp);VS.MatrixAnglesQ(mat,q);return q}function VS::MatrixAngles(matrix,angles=_VEC,position=null){if(position)MatrixGetColumn(matrix,3,position);matrix=matrix.m_flMatVal;local forward=[matrix[0][0],matrix[1][0],matrix[2][0]],left=[matrix[0][1],matrix[1][1],matrix[2][1]],up=[null,null,matrix[2][2]];local xyDist=::sqrt(forward[0]*forward[0]+forward[1]*forward[1]);if(xyDist>0.001){angles.y=57.29577951*::atan2(forward[1],forward[0]);angles.x=57.29577951*::atan2(-forward[2],xyDist);angles.z=57.29577951*::atan2(left[2],up[2])}else{angles.y=57.29577951*::atan2(-left[0],left[1]);angles.x=57.29577951*::atan2(-forward[2],xyDist);angles.z=0};return angles}function VS::MatrixAnglesQ(matrix,q=_QUAT,pos=null){if(pos)MatrixGetColumn(matrix,3,pos);matrix=matrix.m_flMatVal;local trace=matrix[0][0]+matrix[1][1]+matrix[2][2]+1.0;if(trace>1.0+1.19209290E-07){q.x=(matrix[2][1]-matrix[1][2]);q.y=(matrix[0][2]-matrix[2][0]);q.z=(matrix[1][0]-matrix[0][1]);q.w=trace}else if(matrix[0][0]>matrix[1][1]&&matrix[0][0]>matrix[2][2]){trace=1.0+matrix[0][0]-matrix[1][1]-matrix[2][2];q.x=trace;q.y=(matrix[1][0]+matrix[0][1]);q.z=(matrix[0][2]+matrix[2][0]);q.w=(matrix[2][1]-matrix[1][2])}else if(matrix[1][1]>matrix[2][2]){trace=1.0+matrix[1][1]-matrix[0][0]-matrix[2][2];q.x=(matrix[0][1]+matrix[1][0]);q.y=trace;q.z=(matrix[2][1]+matrix[1][2]);q.w=(matrix[0][2]-matrix[2][0])}else{trace=1.0+matrix[2][2]-matrix[0][0]-matrix[1][1];q.x=(matrix[0][2]+matrix[2][0]);q.y=(matrix[2][1]+matrix[1][2]);q.z=trace;q.w=(matrix[1][0]-matrix[0][1])};;;QuaternionNormalize(q);return q}function VS::AngleMatrix(angles,matrix,position=null){local ay=0.01745329*angles.y,ax=0.01745329*angles.x,az=0.01745329*angles.z;local sy=::sin(ay),cy=::cos(ay),sp=::sin(ax),cp=::cos(ax),sr=::sin(az),cr=::cos(az);matrix=matrix.m_flMatVal;matrix[0][0]=cp*cy;matrix[1][0]=cp*sy;matrix[2][0]=-sp;local crcy=cr*cy,crsy=cr*sy,srcy=sr*cy,srsy=sr*sy;matrix[0][1]=sp*srcy-crsy;matrix[1][1]=sp*srsy+crcy;matrix[2][1]=sr*cp;matrix[0][2]=(sp*crcy+srsy);matrix[1][2]=(sp*crsy-srcy);matrix[2][2]=cr*cp;matrix[0][3]=0.0;matrix[1][3]=0.0;matrix[2][3]=0.0;if(position){matrix[0][3]=position.x;matrix[1][3]=position.y;matrix[2][3]=position.z}}function VS::AngleIMatrix(angles,matrix,position=null){local ay=0.01745329*angles.y,ax=0.01745329*angles.x,az=0.01745329*angles.z;local sy=::sin(ay),cy=::cos(ay),sp=::sin(ax),cp=::cos(ax),sr=::sin(az),cr=::cos(az);matrix=matrix.m_flMatVal;matrix[0][0]=cp*cy;matrix[0][1]=cp*sy;matrix[0][2]=-sp;matrix[1][0]=sr*sp*cy+cr*-sy;matrix[1][1]=sr*sp*sy+cr*cy;matrix[1][2]=sr*cp;matrix[2][0]=(cr*sp*cy+-sr*-sy);matrix[2][1]=(cr*sp*sy+-sr*cy);matrix[2][2]=cr*cp;matrix[0][3]=0.0;matrix[1][3]=0.0;matrix[2][3]=0.0;if(position){local vecTranslation=VectorRotate(position,matrix)*-1.0;matrix[0][3]=vecTranslation.x;matrix[1][3]=vecTranslation.y;matrix[2][3]=vecTranslation.z}}function VS::MatrixVectors(matrix,pForward,pRight,pUp){MatrixGetColumn(matrix,0,pForward);MatrixGetColumn(matrix,1,pRight);MatrixGetColumn(matrix,2,pUp);VectorMultiply(pRight,-1.0,pRight)}function VS::MatricesAreEqual(src1,src2,flTolerance){src1=src1.m_flMatVal;src2=src2.m_flMatVal;local fabs=::fabs;for(local i=0;i<3;++i){for(local j=0;j<4;++j){if(fabs(src1[i][j]-src2[i][j])>flTolerance)return false}}return true}function VS::MatrixCopy(src,dst){for(local i=0;i<3;++i){for(local j=0;j<4;++j){dst[i][j]=src[i][j]}}return dst}function VS::MatrixInvert(in1,out){in1=in1.m_flMatVal;out=out.m_flMatVal;if(in1==out){a_swap(out[0],1,out[1],0);a_swap(out[0],2,out[2],0);a_swap(out[1],2,out[2],1)}else{out[0][0]=in1[0][0];out[0][1]=in1[1][0];out[0][2]=in1[2][0];out[1][0]=in1[0][1];out[1][1]=in1[1][1];out[1][2]=in1[2][1];out[2][0]=in1[0][2];out[2][1]=in1[1][2];out[2][2]=in1[2][2]};local tmp=[in1[0][3],in1[1][3],in1[2][3]];out[0][3]=-(tmp[0]*out[0][0]+tmp[1]*out[0][1]+tmp[2]*out[0][2]);out[1][3]=-(tmp[0]*out[1][0]+tmp[1]*out[1][1]+tmp[2]*out[1][2]);out[2][3]=-(tmp[0]*out[2][0]+tmp[1]*out[2][1]+tmp[2]*out[2][2])}function VS::MatrixGetColumn(in1,column,out=_VEC){in1=in1.m_flMatVal;out.x=in1[0][column];out.y=in1[1][column];out.z=in1[2][column];return out}function VS::MatrixSetColumn(in1,column,out){out=out.m_flMatVal;out[0][column]=in1.x;out[1][column]=in1.y;out[2][column]=in1.z}function VS::MatrixScaleBy(flScale,out){out=out.m_flMatVal;out[0][0]*=flScale;out[1][0]*=flScale;out[2][0]*=flScale;out[0][1]*=flScale;out[1][1]*=flScale;out[2][1]*=flScale;out[0][2]*=flScale;out[1][2]*=flScale;out[2][2]*=flScale}function VS::MatrixScaleByZero(out){out=out.m_flMatVal;out[0][0]=0.0;out[1][0]=0.0;out[2][0]=0.0;out[0][1]=0.0;out[1][1]=0.0;out[2][1]=0.0;out[0][2]=0.0;out[1][2]=0.0;out[2][2]=0.0}function VS::SetIdentityMatrix(matrix){SetScaleMatrix(1.0,1.0,1.0,matrix)}function VS::SetScaleMatrix(x,y,z,dst){dst=dst.m_flMatVal;dst[0][0]=x;dst[0][1]=0.0;dst[0][2]=0.0;dst[0][3]=0.0;dst[1][0]=0.0;dst[1][1]=y;dst[1][2]=0.0;dst[1][3]=0.0;dst[2][0]=0.0;dst[2][1]=0.0;dst[2][2]=z;dst[2][3]=0.0}function VS::ComputeCenterMatrix(origin,angles,mins,maxs,matrix){local centroid=(mins+maxs)*0.5;AngleMatrix(angles,matrix);local worldCentroid=VectorRotate(centroid,matrix)+origin;matrix[0][3]=worldCentroid.x;matrix[1][3]=worldCentroid.y;matrix[2][3]=worldCentroid.z}function VS::ComputeCenterIMatrix(origin,angles,mins,maxs,matrix){local centroid=(mins+maxs)*-0.5;AngleIMatrix(angles,matrix);local localOrigin=VectorRotate(origin,matrix);centroid-=localOrigin;matrix[0][3]=centroid.x;matrix[1][3]=centroid.y;matrix[2][3]=centroid.z}function VS::ComputeAbsMatrix(in1,out){in1=in1.m_flMatVal;out=out.m_flMatVal;local fabs=::fabs;out[0][0]=fabs(in1[0][0]);out[0][1]=fabs(in1[0][1]);out[0][2]=fabs(in1[0][2]);out[1][0]=fabs(in1[1][0]);out[1][1]=fabs(in1[1][1]);out[1][2]=fabs(in1[1][2]);out[2][0]=fabs(in1[2][0]);out[2][1]=fabs(in1[2][1]);out[2][2]=fabs(in1[2][2])}function VS::ConcatRotations(in1,in2,out){in1=in1.m_flMatVal;in2=in2.m_flMatVal;out=out.m_flMatVal;out[0][0]=in1[0][0]*in2[0][0]+in1[0][1]*in2[1][0]+in1[0][2]*in2[2][0];out[0][1]=in1[0][0]*in2[0][1]+in1[0][1]*in2[1][1]+in1[0][2]*in2[2][1];out[0][2]=in1[0][0]*in2[0][2]+in1[0][1]*in2[1][2]+in1[0][2]*in2[2][2];out[1][0]=in1[1][0]*in2[0][0]+in1[1][1]*in2[1][0]+in1[1][2]*in2[2][0];out[1][1]=in1[1][0]*in2[0][1]+in1[1][1]*in2[1][1]+in1[1][2]*in2[2][1];out[1][2]=in1[1][0]*in2[0][2]+in1[1][1]*in2[1][2]+in1[1][2]*in2[2][2];out[2][0]=in1[2][0]*in2[0][0]+in1[2][1]*in2[1][0]+in1[2][2]*in2[2][0];out[2][1]=in1[2][0]*in2[0][1]+in1[2][1]*in2[1][1]+in1[2][2]*in2[2][1];out[2][2]=in1[2][0]*in2[0][2]+in1[2][1]*in2[1][2]+in1[2][2]*in2[2][2]}function VS::ConcatTransforms(in1,in2,out){in1=in1.m_flMatVal;in2=in2.m_flMatVal;local rowA0=in1[0],rowA1=in1[1],rowA2=in1[2];local rowB0=in2[0],rowB1=in2[1],rowB2=in2[2];local out0=[(rowA0[0]*rowB0[0]+rowA0[1]*rowB1[0]+rowA0[2]*rowB2[0])+(rowA0[0]&0),(rowA0[0]*rowB0[1]+rowA0[1]*rowB1[1]+rowA0[2]*rowB2[1])+(rowA0[1]&0),(rowA0[0]*rowB0[2]+rowA0[1]*rowB1[2]+rowA0[2]*rowB2[2])+(rowA0[2]&0),(rowA0[0]*rowB0[3]+rowA0[1]*rowB1[3]+rowA0[2]*rowB2[3])+(rowA0[3]&0xFFFFFFFF)],out1=[(rowA1[0]*rowB0[0]+rowA1[1]*rowB1[0]+rowA1[2]*rowB2[0])+(rowA1[0]&0),(rowA1[0]*rowB0[1]+rowA1[1]*rowB1[1]+rowA1[2]*rowB2[1])+(rowA1[1]&0),(rowA1[0]*rowB0[2]+rowA1[1]*rowB1[2]+rowA1[2]*rowB2[2])+(rowA1[2]&0),(rowA1[0]*rowB0[3]+rowA1[1]*rowB1[3]+rowA1[2]*rowB2[3])+(rowA1[3]&0xFFFFFFFF)],out2=[(rowA2[0]*rowB0[0]+rowA2[1]*rowB1[0]+rowA2[2]*rowB2[0])+(rowA2[0]&0),(rowA2[0]*rowB0[1]+rowA2[1]*rowB1[1]+rowA2[2]*rowB2[1])+(rowA2[1]&0),(rowA2[0]*rowB0[2]+rowA2[1]*rowB1[2]+rowA2[2]*rowB2[2])+(rowA2[2]&0),(rowA2[0]*rowB0[3]+rowA2[1]*rowB1[3]+rowA2[2]*rowB2[3])+(rowA2[3]&0xFFFFFFFF)];out=out.m_flMatVal;out[0][0]=out0[0];out[0][1]=out0[1];out[0][2]=out0[2];out[0][3]=out0[3];out[1][0]=out1[0];out[1][1]=out1[1];out[1][2]=out1[2];out[1][3]=out1[3];out[2][0]=out2[0];out[2][1]=out2[1];out[2][2]=out2[2];out[2][3]=out2[3]}function VS::MatrixBuildRotationAboutAxis(vAxisOfRot,angleDegrees,dst){local radians=angleDegrees*0.01745329;local fSin=::sin(radians),fCos=::cos(radians);local axisXSquared=vAxisOfRot[0]*vAxisOfRot[0],axisYSquared=vAxisOfRot[1]*vAxisOfRot[1],axisZSquared=vAxisOfRot[2]*vAxisOfRot[2];dst=dst.m_flMatVal;dst[0][0]=axisXSquared+(1-axisXSquared)*fCos;dst[1][0]=vAxisOfRot[0]*vAxisOfRot[1]*(1-fCos)+vAxisOfRot[2]*fSin;dst[2][0]=vAxisOfRot[2]*vAxisOfRot[0]*(1-fCos)-vAxisOfRot[1]*fSin;dst[0][1]=vAxisOfRot[0]*vAxisOfRot[1]*(1-fCos)-vAxisOfRot[2]*fSin;dst[1][1]=axisYSquared+(1-axisYSquared)*fCos;dst[2][1]=vAxisOfRot[1]*vAxisOfRot[2]*(1-fCos)+vAxisOfRot[0]*fSin;dst[0][2]=vAxisOfRot[2]*vAxisOfRot[0]*(1-fCos)+vAxisOfRot[1]*fSin;dst[1][2]=vAxisOfRot[1]*vAxisOfRot[2]*(1-fCos)-vAxisOfRot[0]*fSin;dst[2][2]=axisZSquared+(1-axisZSquared)*fCos;dst[0][3]=0;dst[1][3]=0;dst[2][3]=0}function VS::TransformAABB(transform,vecMinsIn,vecMaxsIn,vecMinsOut,vecMaxsOut){local localCenter=(vecMinsIn+vecMaxsIn)*0.5;local localExtents=vecMaxsIn-localCenter;local worldCenter=VectorTransform(localCenter,transform);transform=transform.m_flMatVal;local fabs=::fabs;local worldExtents=::Vector(fabs(localExtents.x*transform[0][0])+fabs(localExtents.y*transform[0][1])+fabs(localExtents.z*transform[0][2]),fabs(localExtents.x*transform[1][0])+fabs(localExtents.y*transform[1][1])+fabs(localExtents.z*transform[1][2]),fabs(localExtents.x*transform[2][0])+fabs(localExtents.y*transform[2][1])+fabs(localExtents.z*transform[2][2]));VectorSubtract(worldCenter,worldExtents,vecMinsOut);VectorAdd(worldCenter,worldExtents,vecMaxsOut)}function VS::ITransformAABB(transform,vecMinsIn,vecMaxsIn,vecMinsOut,vecMaxsOut){local worldCenter=(vecMinsIn+vecMaxsIn)*0.5;local worldExtents=vecMaxsIn-worldCenter;local localCenter=VectorITransform(worldCenter,transform);transform=transform.m_flMatVal;local fabs=::fabs;local localExtents=::Vector(fabs(worldExtents.x*transform[0][0])+fabs(worldExtents.y*transform[1][0])+fabs(worldExtents.z*transform[2][0]),fabs(worldExtents.x*transform[0][1])+fabs(worldExtents.y*transform[1][1])+fabs(worldExtents.z*transform[2][1]),fabs(worldExtents.x*transform[0][2])+fabs(worldExtents.y*transform[1][2])+fabs(worldExtents.z*transform[2][2]));VectorSubtract(localCenter,localExtents,vecMinsOut);VectorAdd(localCenter,localExtents,vecMaxsOut)}function VS::RotateAABB(transform,vecMinsIn,vecMaxsIn,vecMinsOut,vecMaxsOut){local localCenter=(vecMinsIn+vecMaxsIn)*0.5;local localExtents=vecMaxsIn-localCenter;local newCenter=VectorRotate(localCenter,transform);transform=transform.m_flMatVal;local fabs=::fabs;local newExtents=::Vector(fabs(localExtents.x*transform[0][0])+fabs(localExtents.y*transform[0][1])+fabs(localExtents.z*transform[0][2]),fabs(localExtents.x*transform[1][0])+fabs(localExtents.y*transform[1][1])+fabs(localExtents.z*transform[1][2]),fabs(localExtents.x*transform[2][0])+fabs(localExtents.y*transform[2][1])+fabs(localExtents.z*transform[2][2]));VectorSubtract(newCenter,newExtents,vecMinsOut);VectorAdd(newCenter,newExtents,vecMaxsOut)}function VS::IRotateAABB(transform,vecMinsIn,vecMaxsIn,vecMinsOut,vecMaxsOut){local oldCenter=(vecMinsIn+vecMaxsIn)*0.5;local oldExtents=vecMaxsIn-oldCenter;local newCenter=VectorIRotate(oldCenter,transform);transform=transform.m_flMatVal;local fabs=::fabs;local newExtents=::Vector(fabs(oldExtents.x*transform[0][0])+fabs(oldExtents.y*transform[1][0])+fabs(oldExtents.z*transform[2][0]),fabs(oldExtents.x*transform[0][1])+fabs(oldExtents.y*transform[1][1])+fabs(oldExtents.z*transform[2][1]),fabs(oldExtents.x*transform[0][2])+fabs(oldExtents.y*transform[1][2])+fabs(oldExtents.z*transform[2][2]));VectorSubtract(newCenter,newExtents,vecMinsOut);VectorAdd(newCenter,newExtents,vecMaxsOut)}
